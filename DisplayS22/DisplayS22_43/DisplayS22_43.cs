using Microsoft.SPOT;
using Microsoft.SPOT.Hardware;
using System.Threading;
using GT = Gadgeteer;
using GTI = Gadgeteer.SocketInterfaces;
using GTM = Gadgeteer.Modules;

namespace Gadgeteer.Modules.KKS
{
    /// <summary>
    /// A DisplayS22 module for Microsoft .NET Gadgeteer
    /// </summary>
    public class DisplayS22 : Module.DisplayModule
    {
        // This example implements a driver in managed code for a simple Gadgeteer module.  This module uses a 
        // single GTI.InterruptInput to interact with a button that can be in either of two states: pressed or released.
        // The example code shows the recommended code pattern for exposing a property (IsPressed). 
        // The example also uses the recommended code pattern for exposing two events: Pressed and Released. 
        // The triple-slash "///" comments shown will be used in the build process to create an XML file named
        // GTM.KKSolutions.Display_SP22. This file will provide IntelliSense and documentation for the
        // interface and make it easier for developers to use the Display_SP22 module.        

        // -- CHANGE FOR MICRO FRAMEWORK 4.2 --
        // If you want to use Serial, SPI, or DaisyLink (which includes GTI.SoftwareI2C), you must do a few more steps
        // since these have been moved to separate assemblies for NETMF 4.2 (to reduce the minimum memory footprint of Gadgeteer)
        // 1) add a reference to the assembly (named Gadgeteer.[interfacename])
        // 2) in GadgeteerHardware.xml, uncomment the lines under <Assemblies> so that end user apps using this module also add a reference.


        #region Fields
        private uint spiSpeed = 8000; // kHz
        private GTI.Spi spi;
        private GTI.SpiConfiguration spiConfig;
        private SPI.Configuration netMFSpiConfig; // needed for Mainboard.NativeBitmapCopyToSpi()

        private GT.Socket socket;
        private GTI.DigitalOutput pinReset;
        private GTI.DigitalOutput pinBacklight;
        private GTI.DigitalOutput pinDC;
        #endregion

        #region Properties
        /// <summary>
        /// Gets the width of the display.
        /// </summary>
        /// <remarks>
        /// This property always returns 240.
        /// </remarks>
        public new int Width
        {
            get { return 240; }
        }

        /// <summary>
        /// Gets the height of the display.
        /// </summary>
        /// <remarks>
        /// This property always returns 320.
        /// </remarks>
        public new int Height
        {
            get { return 320; }
        }
        #endregion

        #region Constructor
        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="socketNumber">The socket that this module is plugged in to.</param>
        /// <param name="socketNumberTwo">The second socket that this module is plugged in to.</param>
        public DisplayS22(int socketNumber)//, int socketNumberTwo)
            : base(DisplayModule.WpfMode.Separate)
        {
            // This finds the Socket instance from the user-specified socket number.  
            // This will generate user-friendly error messages if the socket is invalid.
            // If there is more than one socket on this module, then instead of "null" for the last parameter, 
            // put text that identifies the socket to the user (e.g. "S" if there is a socket type S)
            socket = Socket.GetSocket(socketNumber, true, this, null);
            socket.EnsureTypeIsSupported('S', this);

            socket.ReservePin(Socket.Pin.Three, this); // reset
            socket.ReservePin(Socket.Pin.Four, this); // back light
            socket.ReservePin(Socket.Pin.Five, this); // D/C
            socket.ReservePin(Socket.Pin.Six, this); // CS
            socket.ReservePin(Socket.Pin.Seven, this); // MOSI
            socket.ReservePin(Socket.Pin.Eight, this); // MISO
            socket.ReservePin(Socket.Pin.Nine, this); // SCK

            /*
             * Serial peripheral interface (SPI).
             * Pin 7 is MOSI line, pin 8 is MISO line, pin 9 is SCK line.
             * In addition, pins 3, 4 and 5 are general-purpose input/outputs, with pin 3 supporting interrupt capabilities.
            */

            pinReset = GTI.DigitalOutputFactory.Create(socket, Socket.Pin.Three, false, this); // pin 3
            pinBacklight = GTI.DigitalOutputFactory.Create(socket, Socket.Pin.Four, false, this); // pin 4
            pinDC = GTI.DigitalOutputFactory.Create(socket, Socket.Pin.Five, false, this); // pin 5

            spiConfig = new GTI.SpiConfiguration(false, 0, 0, false, true, spiSpeed);
            netMFSpiConfig = new SPI.Configuration(socket.CpuPins[6], spiConfig.IsChipSelectActiveHigh, spiConfig.ChipSelectSetupTime, spiConfig.ChipSelectHoldTime, spiConfig.IsClockIdleHigh, spiConfig.IsClockSamplingEdgeRising, spiConfig.ClockRateKHz, socket.SPIModule);
            spi = GTI.SpiFactory.Create(socket, spiConfig, GTI.SpiSharing.Shared, socket, Socket.Pin.Six, this);

            Reset();
            ConfigureDisplay();
            Clear();
            SetBacklight(true);
        }
        #endregion

        #region Public methods
        /// <summary>
        /// Enables or disables the display backlight.
        /// </summary>
        /// <param name="state">The state to set the backlight to.</param>
        public void SetBacklight(bool state)
        {
            pinBacklight.Write(state);
        }

        /// <summary>
        /// Clears the display.
        /// </summary>
        public void Clear()
        {
            int w2 = Width / 2;
            int h2 = Height / 2;

            byte[] data = new byte[w2 * h2 * 2]; //zero-inited by default

            DrawRaw(data, 0, 0, w2, h2);
            DrawRaw(data, w2, 0, w2, h2);
            DrawRaw(data, 0, h2, w2, h2);
            DrawRaw(data, w2, h2, w2, h2);
        }

        /// <summary>
        /// Draws an image to the screen.
        /// </summary>
        /// <param name="bmp">The bitmap to be drawn to the screen</param>
        /// <param name="x">Starting X position of the image.</param>
        /// <param name="y">Starting Y position of the image.</param>
        public void Draw(Bitmap bmp, int x = 0, int y = 0)
        {
            byte[] rawData = new byte[bmp.Width * bmp.Height * 2];
            Module.Mainboard.NativeBitmapConverter(bmp, rawData, Mainboard.BPP.BPP16_BGR_BE);
            DrawRaw(rawData, x, y, bmp.Width, bmp.Height);
        }

        /// <summary>
        /// Draws an image to the specified position on the screen.
        /// </summary>
        /// <param name="rawData">Raw Bitmap data to be drawn to the screen.</param>
        /// <param name="width">Width of the image.</param>
        /// <param name="height">Height of the image.</param>
        /// <param name="x">Starting X position of the image.</param>
        /// <param name="y">Starting Y position of the image.</param>
        public void DrawRaw(byte[] rawData, int x, int y, int width, int height)
        {
            if (x > Width || y > Height)
                return;

            if (x + width > Width)
                width = Width - x;
            if (y + height > Height)
                height = Height - y;

            SetClippingArea(x, y, width - 1, height - 1);

            WriteCommand(0x2C); // memory set
            WriteData(rawData);
        }
        #endregion

        #region Private methods
        /// <summary>
        /// Renders Bitmap data on the display device. 
        /// </summary>
        /// <param name="bitmap">The <see cref="T:Microsoft.SPOT.Bitmap"/> object to render on the display.</param>
        protected override void Paint(Bitmap bitmap, int x, int y, int width, int height)
        {
            try
            {
                if (Mainboard.NativeBitmapCopyToSpi != null)
                {
                    SetClippingArea(0, 0, bitmap.Width - 1, bitmap.Height - 1);
                    WriteCommand(0x2C);
                    pinDC.Write(true);
                    Mainboard.NativeBitmapCopyToSpi(bitmap, netMFSpiConfig, 0, 0, bitmap.Width, bitmap.Height, GT.Mainboard.BPP.BPP16_BGR_BE);
                }
                else
                    Draw(bitmap);
            }
            catch
            {
                ErrorPrint("Painting error");
            }
        }

        private void Reset()
        {
            pinReset.Write(false);
            Thread.Sleep(150);
            pinReset.Write(true);
        }
        private void ConfigureDisplay()
        {
            //Module.DisplayModule.SetLCDConfig(new Mainboard.LCDConfiguration()
            //{
            //    LCDControllerEnabled = false,
            //    Width = Width,
            //    Height = Height
            //});

            WriteCommand(0xCB);
            WriteData(0x39);
            WriteData(0x2C);
            WriteData(0x00);
            WriteData(0x34);
            WriteData(0x02);

            WriteCommand(0xCF);
            WriteData(0x00);
            WriteData(0XC1);
            WriteData(0X30);

            WriteCommand(0xE8);
            WriteData(0x85);
            WriteData(0x00);
            WriteData(0x78);

            WriteCommand(0xEA);
            WriteData(0x00);
            WriteData(0x00);

            WriteCommand(0xED);
            WriteData(0x64);
            WriteData(0x03);
            WriteData(0X12);
            WriteData(0X81);

            WriteCommand(0xF7);
            WriteData(0x20);

            WriteCommand(0xC0);    //Power control 
            WriteData(0x23);   //VRH[5:0] 

            WriteCommand(0xC1);    //Power control 
            WriteData(0x10);   //SAP[2:0];BT[3:0] 

            WriteCommand(0xC5);    //VCM control 
            WriteData(0x3e);   //Contrast
            WriteData(0x28);

            WriteCommand(0xC7);    //VCM control2 
            WriteData(0x86);   //--

            WriteCommand(0x36);    // Memory Access Control 
            WriteData(0x48);

            WriteCommand(0x3A);
            WriteData(0x55);

            WriteCommand(0xB1);
            WriteData(0x00);
            WriteData(0x18);

            WriteCommand(0xB6);    // Display Function Control 
            WriteData(0x08);
            WriteData(0x82);
            WriteData(0x27);

            /*
            WriteCommand(0xF2);    // 3Gamma Function Disable 
            WriteData(0x00); 
 
            WriteCommand(0x26);    //Gamma curve selected 
            WriteData(0x01); 

            WriteCommand(0xE0);    //Set Gamma 
            WriteData(0x0F); 
            WriteData(0x31); 
            WriteData(0x2B); 
            WriteData(0x0C); 
            WriteData(0x0E); 
            WriteData(0x08); 
            WriteData(0x4E); 
            WriteData(0xF1); 
            WriteData(0x37); 
            WriteData(0x07); 
            WriteData(0x10); 
            WriteData(0x03); 
            WriteData(0x0E); 
            WriteData(0x09); 
            WriteData(0x00); 

            WriteCommand(0XE1);    //Set Gamma 
            WriteData(0x00); 
            WriteData(0x0E); 
            WriteData(0x14); 
            WriteData(0x03); 
            WriteData(0x11); 
            WriteData(0x07); 
            WriteData(0x31); 
            WriteData(0xC1); 
            WriteData(0x48); 
            WriteData(0x08); 
            WriteData(0x0F); 
            WriteData(0x0C); 
            WriteData(0x31); 
            WriteData(0x36); 
            WriteData(0x0F); 
            */

            WriteCommand(0x11);    //Exit Sleep 
            Thread.Sleep(120);

            //WriteCommand(0x28);    //Display off
            WriteCommand(0x29);    //Display on 
            WriteCommand(0x2c);

            //WriteCommand(0x21);     // Display inversion ON
            //WriteCommand(0x20);     // Display inversion OFF

            //WriteCommand(0x39);     // Idle mode on
            //WriteCommand(0x38);     // Idle mode off

            WriteCommand(0x51);     // brightness
            WriteData(0x88);        //0x00...0xFF
        }
        private void SetClippingArea(int x, int y, int w, int h)
        {
            WriteCommand(0x2A);
            WriteData(new ushort[2] { (ushort)x, (ushort)(x + w) });

            WriteCommand(0x2B);
            WriteData(new ushort[2] { (ushort)y, (ushort)(y + h) });
        }

        private void WriteCommand(byte command)
        {
            pinDC.Write(false);
            spi.Write(new byte[1] { command });
        }
        private void WriteData(byte data)
        {
            WriteData(new byte[1] { data });
        }
        private void WriteData(byte[] data)
        {
            pinDC.Write(true);
            spi.Write(data);
        }
        private void WriteData(ushort[] data)
        {
            pinDC.Write(true);
            spi.Write(data);
        }
        #endregion
    }
}
